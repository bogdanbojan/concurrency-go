
# Concurrency Patterns in Go #

## Confinement ##

For safe operations, we have different options:

- synchronization primitives for sharing memory (e.g. `sync.Mutex`)
- synchronization via communicating (e.g. `channels`)

and

- immutable data
- data protected by confinement

---

Confinement can be of two types:
- ad hoc
- lexical

Adhoc confinement is hard to control.Maybe, it can be used if your team is actively using static analysis. In the example below, `data` is used only by the `loopData` function. 

```
data := make([]int, 4)

loopData := func(handleData chan<- int) {
    defer close(handleData)
    for i := range data {
        handleData <- data[i]
    }
}

handleData := make(chan int)
go loopData(handleData)

for num := range handleData {
    fmt.Println(num)
}
```

Lexical confinement involves using lexical scope to expose the correct data.

```
chanOwner := func() <-chan int {
    results := make(chan int, 5)
    go func() {
        defer close(results)
        for i := 0; i <= 5; i++ {
            results <- i
        }
    }()
    return results
}

consumer := func(results <-chan int) {
    for result := range results {
        fmt.Printf("Received: %d\n", result)
    }
    fmt.Println("Done receiving!")
}

results := chanOwner()
consumer(results)
```