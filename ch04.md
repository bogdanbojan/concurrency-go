
# Concurrency Patterns in Go #

## Confinement ##

For safe operations, we have different options:

- synchronization primitives for sharing memory (e.g. `sync.Mutex`)
- synchronization via communicating (e.g. `channels`)

and

- immutable data
- data protected by confinement

---

Confinement can be of two types:
- ad hoc
- lexical

Adhoc confinement is hard to control.Maybe, it can be used if your team is actively using static analysis. In the example below, `data` is used only by the `loopData` function. 

```
data := make([]int, 4)

loopData := func(handleData chan<- int) {
    defer close(handleData)
    for i := range data {
        handleData <- data[i]
    }
}

handleData := make(chan int)
go loopData(handleData)

for num := range handleData {
    fmt.Println(num)
}
```

Lexical confinement involves using lexical scope to expose the correct data.

```
chanOwner := func() <-chan int {
    results := make(chan int, 5)
    go func() {
        defer close(results)
        for i := 0; i <= 5; i++ {
            results <- i
        }
    }()
    return results
}

consumer := func(results <-chan int) {
    for result := range results {
        fmt.Printf("Received: %d\n", result)
    }
    fmt.Println("Done receiving!")
}

results := chanOwner()
consumer(results)
```

## The for-select Loop ##

This is regular pattern in Go. It is usually used to:

- Sending iteration variables out on an channel
```
for _, s := range []string{"a", "b", "c"} {
    select {
    case <-done:
        return
    case stringStream <- s:
    }
}
```
- Looping infinitely waiting to be stopped
```
// Embedding the work in a `default` clause.
for {
    select {
    case <-done:
        return
    default:
    // Do non-preemptable work
    }
}

// Keeping the `select` statement as short as possible.
for {
    select {
    case <-done:
        return
    default:
    }
// Do non-preemptable work
}
```

## Preventing Goroutine Leaks ##

We don't want to have a goroutine that remains throughout the lifetime of the process by mistake. Like here:
```
doWork := func(strings <-chan string) <-chan interface{} {
    completed := make(chan interface{})
    go func() {
        defer fmt.Println("doWork exited.")
        defer close(completed)
        for s := range strings {
            // Do something interesting
            fmt.Println(s)
        }
    }()
    return completed
}

doWork(nil)
// Perhaps more work is done here
fmt.Println("Done.")
```

A way to mitigate this is to use a signal for the cancellation of the child goroutines through its parent. For example:

```
doWork := func(
    done <-chan interface{},
    strings <-chan string,
    ) <-chan interface{} {
        terminated := make(chan interface{})
        go func() {
            defer fmt.Println("doWork exited.")
            defer close(terminated)
            for {
                select {
                case s := <-strings:
                    fmt.Println(s)
                case <-done:
                    return
                }
            }
        }()
        return terminated
}

done := make(chan interface{})
terminated := doWork(done, nil)

go func() {
    // Cancel the operation after 1 second.
    time.Sleep(1 * time.Second)
    fmt.Println("Canceling doWork goroutine...")
    close(done)
}()

<-terminated
fmt.Println("Done.")
```
---

In the same vein, a goroutine can be blocked when attempting to write a value to a channel. Like here:

```
newRandStream := func() <-chan int {
    randStream := make(chan int)
    go func() {
        defer fmt.Println("newRandStream closure exited.") 
        defer close(randStream)
        for {
            randStream <- rand.Int()
        }
    }()

    return randStream
}

randStream := newRandStream()
fmt.Println("3 random ints:")
for i := 1; i <= 3; i++ {
    fmt.Printf("%d: %d\n", i, <-randStream)
}
```

The `fmt.Println` statement never gets run. A possible solution would be to provide the producer goroutine with a channel informing it to exit:

```
newRandStream := func(done <-chan interface{}) <-chan int { randStream := make(chan int)
    go func() {
        defer fmt.Println("newRandStream closure exited.")
        defer close(randStream)
        for {
            select {
            case randStream <- rand.Int():
            case <-done:
                return
            }
        }
    }()

    return randStream
}

done := make(chan interface{})
randStream := newRandStream(done)
fmt.Println("3 random ints:")
for i := 1; i <= 3; i++ {
    fmt.Printf("%d: %d\n", i, <-randStream)
}
close(done)

// Simulate ongoing work
time.Sleep(1 * time.Second)
```

## The or-channel ##

Sometimes you want to combine one or more `done` channels into a single `done ` channel that closes if any of its component channels close. You can write a `select` statement that does this..if you know the number of `done` channels you're working with by runtime. 

```
var or func(channels ...<-chan interface{}) <-chan interface{}
or = func(channels ...<-chan interface{}) <-chan interface{} { 
    switch len(channels) {
    case 0: 
        return nil
    case 1: 
        return channels[0]
    }

    orDone := make(chan interface{})
    go func() { 
        defer close(orDone)

        switch len(channels) {
        case 2: 
            select {
            case <-channels[0]:
            case <-channels[1]:
            }
        default: 
            select {
            case <-channels[0]:
            case <-channels[1]:
            case <-channels[2]:
            case <-or(append(channels[3:], orDone)...): 
            }
        }
    }()
    return orDone
}
sig := func(after time.Duration) <-chan interface{} { 
    c := make(chan interface{})
    go func() {
        defer close(c)
        time.Sleep(after)
    }()
    return c
}

start := time.Now() 
<-or(
    sig(2*time.Hour),
    sig(5*time.Minute),
    sig(1*time.Second),
    sig(1*time.Hour),
    sig(1*time.Minute),
)
fmt.Printf("done after %v", time.Since(start)) 
```

This can be helpful especially at the intersection of modules in your system - where you have multiple conditions for cancelling trees of goroutines through the call stack.

## Error Handling ##

"Who should be responsible for handling the error?"

This rings true especially in concurrent processes with parent-sibling relationships. The complexity rises and we need to handle things in a logical manner. Like here:

```
type Result struct { 
    Error    error
    Response *http.Response
}

checkStatus := func(done <-chan interface{}, urls ...string) <-chan Result { 
    results := make(chan Result)
    go func() {
        defer close(results)

        for _, url := range urls {
            var result Result
            resp, err := http.Get(url)
            result = Result{Error: err, Response: resp} 
            select {
            case <-done:
                return
            case results <- result: 
            }
        }
    }()
    return results
}

done := make(chan interface{})
defer close(done)

urls := []string{"https://www.google.com", "https://badhost"}
for result := range checkStatus(done, urls...) {
    // Another approach would be to introduce an errCount variable to keep track of 
    // how many errors you get and stop the loop after a specific number.
    if result.Error != nil { 
        fmt.Printf("error: %v", result.Error)
        continue
    }
    fmt.Printf("Response: %v\n", result.Response.Status)
}
```

Errors should be considered first-class citizens when constructing values to return from goroutines. Especially in more complex scenarios. Good ideas to have tight coupling with the results and use the same lines of communications..